#include "Block.h"
#include <sstream>
#include <iomanip>
#include <openssl/sha.h>

Block::Block(std::vector<Transaction> transactions, std::string prevHash, int difficulty) {
    this->transactions = transactions;
    this->prevHash = prevHash;
    this->timestamp = std::time(nullptr);
    this->difficulty = difficulty;
    this->nonce = 0;
    this->blockHash = mineBlock(); // Compute the block's hash
}

std::string Block::mineBlock() {
    std::string target(difficulty, '0');
    while (blockHash.substr(0, difficulty) != target) {
        nonce++;
        blockHash = generateHash();
    }
    return blockHash;
}

std::string Block::generateHash() const {
    std::stringstream ss;
    ss << std::put_time(std::gmtime(&timestamp), "%Y-%m-%dT%H:%M:%S");
    for (const auto& tx : transactions) {
        ss << tx.sender << tx.receiver << tx.amount;
    }
    ss << prevHash << nonce;
    return sha256(ss.str());
}

std::string Block::sha256(const std::string str) const {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, str.c_str(), str.size());
    SHA256_Final(hash, &sha256);

    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
    }
    return ss.str();
}
#include "Blockchain.h"
#include "Wallet.h"
#include <iostream>

Blockchain::Blockchain() {
    std::vector<Transaction> emptyTransactions;  // Empty list for genesis block
    chain.emplace_back(emptyTransactions, "0", 2);  // Genesis Block
}

void Blockchain::createTransaction(Transaction transaction) {
    pendingTransactions.push_back(transaction);
}

void Blockchain::minePendingTransactions() {
    Block newBlock(pendingTransactions, chain.back().blockHash, 2);
    chain.push_back(newBlock);
    pendingTransactions.clear();  // Clear pending transactions
}

bool Blockchain::isBlockHashValid(const Block& block) {
    return block.blockHash == block.generateHash();
}

bool Blockchain::isTransactionValid(const Transaction& tx) {
    return tx.amount > 0;
}

bool Blockchain::isChainValid() {
    for (int i = 1; i < chain.size(); ++i) {
        Block currBlock = chain[i];
        Block prevBlock = chain[i - 1];

        if (!isBlockHashValid(currBlock)) {
            return false;
        }

        if (currBlock.prevHash != prevBlock.blockHash) {
            return false;
        }

        for (const auto& tx : currBlock.transactions) {
            RSA* publicKey = publicKeyMap[tx.sender];  // Retrieve publicKey based on tx.sender
            if (!tx.isValid(publicKey)) {
                return false;
            }
        }
    }
    return true;
}



void Blockchain::printChain() {
    for (const auto& block : chain) {
        std::cout << "Block Timestamp: " << block.timestamp << std::endl;
        std::cout << "Previous Hash: " << block.prevHash << std::endl;
        std::cout << "Block Hash: " << block.blockHash << std::endl;
        std::cout << "Transactions:" << std::endl;
        
        for (const auto& tx : block.transactions) {
            std::cout << "  Sender: " << tx.sender << " Receiver: " << tx.receiver << " Amount: " << tx.amount << std::endl;
        }
        
        std::cout << "Nonce: " << block.nonce << std::endl;  // Display the nonce
        std::cout << std::endl;
    }
}

void Blockchain::notifyWallets(std::vector<Wallet*>& wallets) {

    for (auto& wallet : wallets) {
        publicKeyMap[wallet->id] = wallet->publicKey;  // Store the public key in the map
        for (auto& block : chain) {
            wallet->updateBalance(block.transactions);
        }
    }
}



#include "Transaction.h"
#include <openssl/sha.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <iostream>

Transaction::Transaction(std::string sender, std::string receiver, float amount, int nonce)
    : sender(sender), receiver(receiver), amount(amount), nonce(nonce) {}

void Transaction::sign(RSA* privateKey) {
    std::string dataToSign = sender + receiver + std::to_string(amount) + std::to_string(nonce);
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256(reinterpret_cast<const unsigned char*>(dataToSign.c_str()), dataToSign.size(), hash);

    unsigned char sign[256]; // make sure this size is appropriate
    unsigned int sLen;

    if (RSA_sign(NID_sha256, hash, SHA256_DIGEST_LENGTH, sign, &sLen, privateKey) != 1) {
        // Handle error. 
        std::cout << "Signing failed.\n";
        return;
    }

    signature.assign(reinterpret_cast<char*>(sign), sLen);
}

bool Transaction::verify(RSA* publicKey) const {
    // Clear OpenSSL error stack
    ERR_clear_error();

    std::string dataToVerify = sender + receiver + std::to_string(amount) + std::to_string(nonce);
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256(reinterpret_cast<const unsigned char*>(dataToVerify.c_str()), dataToVerify.size(), hash);

    int ret = RSA_verify(NID_sha256, hash, SHA256_DIGEST_LENGTH, reinterpret_cast<const unsigned char*>(signature.c_str()), signature.size(), publicKey);
    
    if (ret != 1) {
        unsigned long err = ERR_get_error();
        char *errStr = ERR_error_string(err, NULL);
        std::cout << "Error occurred during verification: " << errStr << std::endl;
        return false;
    }
    return true;
}

bool Transaction::isValid(RSA* publicKey) const {
    if (nonce < 0 || !(amount > 0)) {
        return false;
    }

    return verify(publicKey);
}
#include "Wallet.h"
#include <iostream>  // Include iostream for std::cerr
#include <openssl/rand.h>

Wallet::Wallet(std::string id) : id(id), balance(0.0f), privateKey(nullptr), publicKey(nullptr) {
    generateKeys();
}

Wallet::~Wallet() {
   if (privateKey) {
    RSA_free(privateKey);
    privateKey = nullptr;
}
if (publicKey) {
    RSA_free(publicKey);
    publicKey = nullptr;
}

}


void Wallet::generateKeys() {
    privateKey = RSA_new();
    BIGNUM* exponent = BN_new();
    BN_set_word(exponent, RSA_F4);  // Public exponent
    RSA_generate_key_ex(privateKey, 2048, exponent, nullptr);
    
    // Create a new RSA object for the public key and set its fields
    publicKey = RSA_new();
    RSA_set0_key(publicKey, BN_dup(RSA_get0_n(privateKey)), BN_dup(exponent), nullptr);
    
    // Free the exponent as it is duplicated in publicKey and privateKey
    BN_free(exponent);
}


Transaction Wallet::sendFunds(Wallet& receiver, float amount) {
    // Generate a nonce (for simplicity, this could be a random number)
    int nonce = 12345;  // Replace with your nonce generation logic

    Transaction tx(id, receiver.id, amount, nonce);
    tx.sign(privateKey);  // Sign the transaction

    return tx;
}

void Wallet::updateBalance(const std::vector<Transaction>& transactions) {
    for (const auto& tx : transactions) {
        if (tx.sender == id) {
            balance -= tx.amount;
        }
        if (tx.receiver == id) {
            if (tx.verify(publicKey)) {  // Verify the transaction
                balance += tx.amount;
            } else {
                std::cerr << "Invalid transaction received.\n";
            }
        }
    }
}
#include <iostream>
#include <vector>
#include "Blockchain.h"
#include "Wallet.h"

int main() {
    Blockchain myBlockchain;
    std::vector<Wallet*> wallets;

    Wallet alice("Alice");
    Wallet bob("Bob");
    Wallet charlie("Charlie");

    alice.balance = 100;
    bob.balance = 100;
    charlie.balance = 0;

    wallets.push_back(&alice);
    wallets.push_back(&bob);
    wallets.push_back(&charlie);

    Transaction tx1 = alice.sendFunds(bob, 50);  
    Transaction tx2 = bob.sendFunds(charlie, 30); 

    myBlockchain.createTransaction(tx1);
    myBlockchain.createTransaction(tx2);

    myBlockchain.minePendingTransactions();

    myBlockchain.notifyWallets(wallets);

    if (myBlockchain.isChainValid()) {
        std::cout << "Blockchain is valid.\n";
    } else {
        std::cout << "Blockchain is not valid!\n";
    }

    myBlockchain.printChain();

    for (const auto& wallet : wallets) {
        std::cout << "Wallet " << wallet->id << " has balance: " << wallet->balance << std::endl;
    }

    return 0;
}
#pragma once
#include <string>
#include <vector>
#include <ctime>
#include "Transaction.h"

class Block {
public:
    std::string prevHash;
    std::string blockHash;
    std::vector<Transaction> transactions;
    std::time_t timestamp;
    int nonce;
    int difficulty;

    Block(std::vector<Transaction> transactions, std::string prevHash, int difficulty);
    std::string mineBlock();
    std::string generateHash() const;
    std::string sha256(const std::string str) const;
};
#pragma once
#include <vector>
#include "Block.h"
#include "Transaction.h"
#include "Wallet.h"

class Blockchain {
private:
    std::vector<Block> chain;
    std::vector<Transaction> pendingTransactions;
    std::unordered_map<std::string, RSA*> publicKeyMap; // New map for public keys


public:
    Blockchain();
    void createTransaction(Transaction transaction);
    void minePendingTransactions();
    bool isBlockHashValid(const Block& block);
    bool isTransactionValid(const Transaction& tx);
    bool isChainValid();
    void printChain();
    void notifyWallets(std::vector<Wallet*>& wallets);
};
#ifndef TRANSACTION_H
#define TRANSACTION_H

#include <string>
#include <openssl/rsa.h>

class Transaction {
public:
    std::string sender;
    std::string receiver;
    float amount;
    std::string signature;
    int nonce;


    Transaction(std::string sender, std::string receiver, float amount, int nonce);
    void sign(RSA* privateKey);  // Sign the transaction
    bool verify(RSA* publicKey) const;  // Verify the transaction
    bool isValid(RSA* publicKey) const;  // Check overall validity

};

#endif // TRANSACTION_H
#ifndef WALLET_H
#define WALLET_H

#include <string>
#include <vector>
#include <openssl/rsa.h>
#include "Transaction.h"

class Wallet {
public:
    Wallet(std::string id);
    ~Wallet();  // Free RSA keys

    Transaction sendFunds(Wallet& receiver, float amount);

    void updateBalance(const std::vector<Transaction>& transactions);

    std::string id;
    float balance;
    RSA* publicKey;   // Make it public or provide a getter method


private:
    RSA* privateKey;  // Private key for signing transactions
    void generateKeys();  // Generate RSA key pair
};

#endif // WALLET_H
